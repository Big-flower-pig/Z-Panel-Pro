#!/bin/bash
# ==============================================================================
# Z-Panel Pro - 文件锁模块
# ==============================================================================
# @description    文件锁管理，防止并发执行
# @version       7.1.0-Enterprise
# @author        Z-Panel Team
# ==============================================================================

# ==============================================================================
# 获取文件锁
# @return: 0为成功，1为失败
# ==============================================================================
acquire_lock() {
    # 打开锁文件描述符
    if ! eval "exec ${LOCK_FD}>\"${LOCK_FILE}\"" 2>/dev/null; then
        log_error "无法创建锁文件: ${LOCK_FILE}"
        return 1
    fi

    # 尝试获取非阻塞锁
    if ! flock -n "${LOCK_FD}" 2>/dev/null; then
        local pid
        pid=$(cat "${LOCK_FILE}" 2>/dev/null || echo "unknown")
        log_error "脚本已在运行中 (PID: ${pid})"
        log_error "如需重新启动，请先运行: rm -f ${LOCK_FILE}"
        return 1
    fi

    # 写入当前PID
    echo $$ > "${LOCK_FILE}" 2>/dev/null

    log_debug "文件锁已获取 (PID: $$)"
    return 0
}

# ==============================================================================
# 释放文件锁
# ==============================================================================
release_lock() {
    if flock -u "${LOCK_FD}" 2>/dev/null; then
        rm -f "${LOCK_FILE}" 2>/dev/null
        log_debug "文件锁已释放"
    fi
}

# ==============================================================================
# 检查是否持有锁
# @return: 0为持有，1为未持有
# ==============================================================================
is_lock_held() {
    flock -n "${LOCK_FD}" 2>/dev/null
}

# ==============================================================================
# 获取锁文件中的PID
# @return: PID或空字符串
# ==============================================================================
get_lock_pid() {
    cat "${LOCK_FILE}" 2>/dev/null || echo ""
}

# ==============================================================================
# 强制释放锁（危险操作）
# @return: 0为成功，1为失败
# ==============================================================================
force_release_lock() {
    log_warn "强制释放文件锁"

    local lock_pid
    lock_pid=$(get_lock_pid)

    if [[ -n "${lock_pid}" ]] && is_process_running "${lock_pid}"; then
        log_warn "锁文件中的进程 ${lock_pid} 仍在运行"
        if ! ui_confirm "确认强制释放？这可能导致数据损坏"; then
            return 1
        fi
    fi

    flock -u "${LOCK_FD}" 2>/dev/null
    rm -f "${LOCK_FILE}" 2>/dev/null
    log_info "文件锁已强制释放"
    return 0
}